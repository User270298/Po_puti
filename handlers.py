import datetime
import os
import logging
from aiogram import types, F, Router, Bot
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from dotenv import load_dotenv
from crud import get_user_trips, register_user, create_trip, User
from keyboards import keyboards_main_menu, keyboards_driver, description_choice_keyboard
from database import SessionLocal
from models import Trip
from aiogram.types import ChatMemberUpdated
from aiogram.filters import ChatMemberUpdatedFilter

load_dotenv()
router = Router()

GROUP_ID = os.getenv("GROUP_ID")  # ID –≥—Ä—É–ø–ø—ã –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–π

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

from functools import wraps


def db_session(func):
    """
    –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–µ–π –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö.
    """

    @wraps(func)
    async def wrapper(*args, **kwargs):
        with SessionLocal() as session:
            kwargs['session'] = session
            return await func(*args, **kwargs)

    return wrapper


class Registration(StatesGroup):
    name = State()
    email = State()
    phone = State()


class Trips(StatesGroup):
    origin = State()
    destination = State()
    departure_time = State()
    seats_available = State()
    price_per_seat = State()
    description = State()


@router.chat_member(ChatMemberUpdatedFilter)
async def handle_system_messages(update: ChatMemberUpdated, bot: Bot):
    """
    –£–¥–∞–ª—è–µ—Ç —Å–∏—Å—Ç–µ–º–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–∏ –∏–ª–∏ –≤—ã—Ö–æ–¥–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.
    """
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—Å—Ç—É–ø–∏–ª –∏–ª–∏ –ø–æ–∫–∏–Ω—É–ª –≥—Ä—É–ø–ø—É
        if update.new_chat_member.status in ["member"] or update.old_chat_member.status in ["left"]:
            print(f"–£–¥–∞–ª—è–µ–º —Å–∏—Å—Ç–µ–º–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø–µ {update.chat.title}")
            await bot.delete_message(chat_id=update.chat.id, message_id=update.message_id)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")


# @router.message(Command(commands=["start"]))
# async def start(message: types.Message):
#     from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
#     # –ö–Ω–æ–ø–∫–∞ —Å —Å—Å—ã–ª–∫–æ–π –Ω–∞ –±–æ—Ç–∞
#     keyboard = InlineKeyboardMarkup(
#         inline_keyboard=[
#             [InlineKeyboardButton(text="üöÄ –û—Ç–∫—Ä—ã—Ç—å –±–æ—Ç–∞", url="https://t.me/on_the_way_rnd_bot")]
#         ]
#     )
#     # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
#     await message.answer(
#         text=(
#             "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≥—Ä—É–ø–ø—É *–ü–æ –ø—É—Ç–∏!* üöó\n\n"
#             "–î–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ø–æ–µ–∑–¥–æ–∫ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞—à–µ–≥–æ –±–æ—Ç–∞.\n–û–Ω –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –Ω–∞–π—Ç–∏ –ø–æ–ø—É—Ç—á–∏–∫–æ–≤ –∏ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å —Å–æ–≤–º–µ—Å—Ç–Ω—ã–µ –ø–æ–µ–∑–¥–∫–∏! üõ§Ô∏è\n\n"
#             "üìå *–ß—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å?*\n"
#             "üöò –ü—É–±–ª–∏–∫–æ–≤–∞—Ç—å –º–∞—Ä—à—Ä—É—Ç—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ–ø—É—Ç—á–∏–∫–æ–≤\n"
#             "üë´ –ù–∞—Ö–æ–¥–∏—Ç—å –ø–æ–ø—É—Ç—á–∏–∫–æ–≤ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–Ω—ã—Ö –ø–æ–µ–∑–¥–æ–∫\n"
#             "üí∞ –≠–∫–æ–Ω–æ–º–∏—Ç—å –Ω–∞ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è—Ö, –¥–µ–ª—è —Ä–∞—Å—Ö–æ–¥—ã\n\n"
#             "üéØ –°–¥–µ–ª–∞–π—Ç–µ —Å–≤–æ–∏ –ø–æ–µ–∑–¥–∫–∏ —É–¥–æ–±–Ω–µ–µ –∏ –¥–µ—à–µ–≤–ª–µ!"
#         ),
#         parse_mode="Markdown",
#         reply_markup=keyboard
#     )


# –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@router.message(Command(commands=["start"]))
@db_session
async def start_command(message: types.Message, state: FSMContext, session):
    logger.info(f"Received /start command from user {message.from_user.id}")
    user = session.query(User).filter_by(telegram_id=message.from_user.id).first()

    if user:
        logger.info(f"User {message.from_user.id} found in database")
        await message.answer("*–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –æ–±—Ä–∞—Ç–Ω–æ!*\n\nüöÄ –í–æ—Ç –≤–∞—à–µ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
                             parse_mode="Markdown", reply_markup=keyboards_main_menu())
    else:
        logger.info(f"User {message.from_user.id} not found in database, starting registration")
        await message.answer(
            "*–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –ï–¥–µ–º –≤–º–µ—Å—Ç–µ –ë–æ—Ç!*\n\n"
            "ü§ñüöò –≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–∂–µ—Ç –≤–∞–º –Ω–∞–π—Ç–∏ –ø–æ–ø—É—Ç—á–∏–∫–æ–≤ –∏–ª–∏ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —Å–≤–æ–∏ –ø–æ–µ–∑–¥–∫–∏.\n\n"
            "–î–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ø–æ–µ–∑–¥–æ–∫ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è. üöÄ",
            parse_mode="Markdown"
        )
        await message.answer("üìã *–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à–µ –∏–º—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.*",
                             parse_mode="Markdown")
        await state.set_state(Registration.name)


@router.message(StateFilter(Registration.name))
async def process_name(message: types.Message, state: FSMContext):
    logger.info(f"User {message.from_user.id} entered name: {message.text}")
    await state.update_data(name=message.text)
    await message.answer("üìß *–í–≤–µ–¥–∏—Ç–µ –≤–∞—à email.*", parse_mode="Markdown")
    await state.set_state(Registration.email)


@router.message(StateFilter(Registration.email))
async def process_email(message: types.Message, state: FSMContext):
    logger.info(f"User {message.from_user.id} entered email: {message.text}")
    await state.update_data(email=message.text)
    await message.answer("üì± *–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞.*", parse_mode="Markdown")
    await state.set_state(Registration.phone)


@router.message(StateFilter(Registration.phone))
@db_session
async def process_phone(message: types.Message, state: FSMContext, session):
    logger.info(f"User {message.from_user.id} entered phone: {message.text}")
    data = await state.get_data()
    register_user(session, telegram_id=message.from_user.id, name=data['name'], email=data['email'], phone=message.text)

    logger.info(f"User {message.from_user.id} successfully registered")
    await message.answer("üéâ *–í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã!*", parse_mode="Markdown", reply_markup=keyboards_main_menu())
    await state.clear()


# –ü—É–±–ª–∏–∫–∞—Ü–∏—è –ø–æ–µ–∑–¥–∫–∏
@router.callback_query(F.data == "publish_trip")
async def create_trip_command(callback: types.CallbackQuery, state: FSMContext):
    logger.info(f"User {callback.message.from_user.id} initiated trip creation")
    await callback.message.answer("üìç *–í–≤–µ–¥–∏—Ç–µ –º–µ—Å—Ç–æ, –æ—Ç–∫—É–¥–∞ –±—É–¥–µ—Ç–µ –≤—ã–µ–∑–∂–∞—Ç—å.*", parse_mode="Markdown")
    await state.set_state(Trips.origin)


@router.message(StateFilter(Trips.origin))
async def trip_origin(message: types.Message, state: FSMContext):
    logger.info(f"User {message.from_user.id} entered trip origin: {message.text}")
    await state.update_data(origin=message.text)
    await message.answer("üèÅ *–í–≤–µ–¥–∏—Ç–µ –∫–æ–Ω–µ—á–Ω—É—é —Ç–æ—á–∫—É –ø–æ–µ–∑–¥–∫–∏.*", parse_mode="Markdown")
    await state.set_state(Trips.destination)


@router.message(StateFilter(Trips.destination))
async def trip_destination(message: types.Message, state: FSMContext):
    logger.info(f"User {message.from_user.id} entered trip destination: {message.text}")
    await state.update_data(destination=message.text)
    await message.answer("üìÖ *–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –∏ –≤—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú).*", parse_mode="Markdown")
    await state.set_state(Trips.departure_time)


@router.message(StateFilter(Trips.departure_time))
async def trip_departure_time(message: types.Message, state: FSMContext):
    try:
        departure_time = datetime.datetime.strptime(message.text, "%d.%m.%Y %H:%M")
        logger.info(f"User {message.from_user.id} entered trip departure time: {message.text}")
        await state.update_data(departure_time=departure_time)
        await message.answer("ü™ë *–í–≤–µ–¥–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–µ—Å—Ç.*", parse_mode="Markdown")
        await state.set_state(Trips.seats_available)
    except ValueError:
        logger.warning(f"User {message.from_user.id} entered invalid date format: {message.text}")
        await message.answer("‚ùå *–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ (–≤ —Ñ–æ—Ä–º–∞—Ç–µ –î–î.–ú–ú.–ì–ì–ì–ì –ß–ß:–ú–ú).*",
                             parse_mode="Markdown")


@router.message(StateFilter(Trips.seats_available))
async def trip_seats_available(message: types.Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("‚ùå *–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–µ—Å—Ç.*", parse_mode="Markdown")
        return

    logger.info(f"User {message.from_user.id} entered seats available: {message.text}")
    await state.update_data(seats_available=int(message.text))
    await message.answer("üí∞ *–í–≤–µ–¥–∏—Ç–µ —Å—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ –º–µ—Å—Ç–æ.*", parse_mode="Markdown")
    await state.set_state(Trips.price_per_seat)





@router.message(StateFilter(Trips.price_per_seat))
async def trip_price_per_seat(message: types.Message, state: FSMContext):
    if not message.text.isdigit():
        await message.answer("‚ùå *–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –∑–∞ –º–µ—Å—Ç–æ.*", parse_mode="Markdown")
        return

    logger.info(f"User {message.from_user.id} entered price per seat: {message.text}")
    await state.update_data(price_per_seat=int(message.text))
    await message.answer(
        "*–•–æ—Ç–∏—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –Ω–∞–ø–∏—Å–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ?*", parse_mode="Markdown",
        reply_markup=description_choice_keyboard()
    )


@router.callback_query(F.data.startswith("description_"))
async def handle_description_choice(callback: types.CallbackQuery, state: FSMContext):
    choice = callback.data.split("_")[1]

    if choice == "yes":
        await callback.message.answer("üìù *–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ–µ–∑–¥–∫–∏.*", parse_mode="Markdown")
        await state.set_state(Trips.description)
    else:
        await state.update_data(description=None)
        await trip_description(callback.message, state)


@router.message(StateFilter(Trips.description))
@db_session
async def trip_description(message: types.Message, state: FSMContext, session):
    logger.info(f"User {message.from_user.id} entered description: {message.text}")
    await state.update_data(description=message.text)
    await trip_description(message, state, session)

@router.message(StateFilter(Trips.description))
@db_session
async def trip_description(message: types.Message, state: FSMContext, session):
    data = await state.get_data()
    logger.info(f"User {message.from_user.id} completed trip details: {data}")

    trip = create_trip(
        session,
        user_id=message.from_user.id,
        origin=data['origin'],
        destination=data['destination'],
        departure_time=data['departure_time'],
        seats_available=data['seats_available'],
        price_per_seat=data['price_per_seat'],
        description=message.text
    )

    logger.info(f"Trip created successfully for user {message.from_user.id}")
    await message.answer("–ü–æ–µ–∑–¥–∫–∞ –æ–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–∞!", reply_markup=keyboards_main_menu())

    # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç
    seats_available = trip.seats_available

    await message.bot.send_message(
        GROUP_ID,
        f"*–ù–æ–≤–∞—è –ø–æ–µ–∑–¥–∫–∞!*\n\n"
        f"üìç *–ú–∞—Ä—à—Ä—É—Ç:* {trip.origin} ‚Üí {trip.destination}\n"
        f"‚è∞ *–í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è:* {trip.departure_time.strftime('%d.%m.%Y %H:%M')}\n"
        f"ü™ë *–ú–µ—Å—Ç–∞:* {seats_available}\n"
        f"üí∞ *–°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ –º–µ—Å—Ç–æ:* {trip.price_per_seat} —Ä—É–±–ª–µ–π\n"
        f"üìù*–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ:* {trip.description}",
        parse_mode="Markdown",
        reply_markup=keyboards_driver(trip.user_id, trip.id, seats_available)  # –ü–µ—Ä–µ–¥–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Å—Ç
    )
    await state.clear()



from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

@router.callback_query(F.data.startswith("book_trip:"))
@db_session
async def book_trip(callback: types.CallbackQuery, session):
    # –ò–∑–≤–ª–µ–∫–∞–µ–º user_id –∏ trip_id –∏–∑ callback_data
    user_id, trip_id = map(int, callback.data.split(":")[1:])

    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–µ–∑–¥–∫—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    trip = session.query(Trip).filter_by(id=trip_id).first()
    if not trip:
        await callback.answer("–ü–æ–µ–∑–¥–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –º–µ—Å—Ç–∞
    if trip.seats_available <= 0:
        await callback.answer("–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –º–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ—Ç.")
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–µ—Å—Ç
    seats_available = trip.seats_available

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–µ–∑–¥–∫–µ
    trip_message = (
        f"üìç *–ú–∞—Ä—à—Ä—É—Ç:* {trip.origin} ‚Üí {trip.destination}\n"
        f"‚è∞ *–í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è:* {trip.departure_time.strftime('%d.%m.%Y %H:%M')}\n"
        f"ü™ë *–ú–µ—Å—Ç–∞:* {seats_available}\n"
        f"üí∞ *–°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ –º–µ—Å—Ç–æ:* {trip.price_per_seat} —Ä—É–±–ª–µ–π\n"
        f"üìù*–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ:* {trip.description}"
    )

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É —Å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –º–µ—Å—Ç
    button_text = f"–•–æ—á—É –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å"
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text=button_text, callback_data=f"book_trip:{user_id}:{trip_id}")]]
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await callback.message.answer(trip_message, parse_mode="Markdown", reply_markup=keyboard)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤–æ–¥–∏—Ç–µ–ª—é
    passenger_name = callback.from_user.full_name or "–ò–º—è —Å–∫—Ä—ã—Ç–æ"
    passenger_username = callback.from_user.username or "–ù–µ —É–∫–∞–∑–∞–Ω–æ"
    driver_message = (
        f"üì¨ *–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–∞ –ø–æ–µ–∑–¥–∫—É!*\n\n"
        f"üë§ *–ò–º—è –ø–∞—Å—Å–∞–∂–∏—Ä–∞:* {passenger_name}\n"
        f"üìá *Username:* @{passenger_username}\n"
        f"üìç *–ú–∞—Ä—à—Ä—É—Ç:* {trip.origin} ‚Üí {trip.destination}\n"
        f"‚è∞ *–í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è:* {trip.departure_time.strftime('%d.%m.%Y %H:%M')}\n"
        f"üí¨ –ù–∞–ø–∏—à–∏—Ç–µ –ø–∞—Å—Å–∞–∂–∏—Ä—É –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π."
    )
    await callback.bot.send_message(chat_id=trip.user_id, text=driver_message, parse_mode="Markdown")

    # –û—Ç–≤–µ—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    await callback.answer("–í—ã —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –∑–∞–ø—Ä–æ—Å –Ω–∞ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–æ–¥–∏—Ç–µ–ª—é.")


# –û–ø–∏—Å–∞–Ω–∏–µ –ø–æ–µ–∑–¥–∫–∏
@router.callback_query(F.data.startswith("view_trip_"))
@db_session
async def view_trip(callback: types.CallbackQuery, session):
    # –ü–æ–ª—É—á–∞–µ–º –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –æ –ø–æ–µ–∑–¥–∫–µ
    trip_id = int(callback.data.split("_")[2])
    trip = session.query(Trip).filter_by(id=trip_id).first()
    if not trip:
        await callback.answer("–ü–æ–µ–∑–¥–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –ø–æ–µ–∑–¥–∫–µ
    trip_message = (
        f"üìç *–ú–∞—Ä—à—Ä—É—Ç:* {trip.origin} ‚Üí {trip.destination}\n"
        f"‚è∞ *–í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∏—è:* {trip.departure_time.strftime('%d.%m.%Y %H:%M')}\n"
        f"ü™ë *–ú–µ—Å—Ç–∞:* {trip.seats_available}\n"
        f"üí∞ *–°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ –º–µ—Å—Ç–æ:* {trip.price_per_seat} —Ä—É–±–ª–µ–π\n"
        f"üí¨ *–û–ø–∏—Å–∞–Ω–∏–µ:* {trip.description}\n"
    )

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É "–•–æ—á—É –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å"
    button_text = f"–•–æ—á—É –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å"
    keyboard = InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text=button_text, callback_data=f"book_trip:{callback.from_user.id}:{trip.id}")]]
    )

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∫–Ω–æ–ø–∫–æ–π
    await callback.message.answer(trip_message, parse_mode="Markdown", reply_markup=keyboard)


@router.callback_query(F.data == "search_trips")
@db_session
async def search_trips(callback: types.CallbackQuery, session):
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–µ–∑–¥–∫–∏
    trips = session.query(Trip).filter_by(status='active').all()

    if not trips:
        await callback.message.answer("üìÖ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–µ–∑–¥–æ–∫.")
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–µ–∑–¥–æ–∫
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    for trip in trips:
        trip_info = f"{trip.origin} ‚Üí {trip.destination} | {trip.departure_time.strftime('%d.%m.%Y %H:%M')}"
        button = InlineKeyboardButton(text=trip_info, callback_data=f"view_trip_{trip.id}")
        keyboard.inline_keyboard.append([button])

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –ø–æ–µ–∑–¥–∫–∞–º–∏
    await callback.message.answer("üìÖ *–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–µ–∑–¥–∫—É:*", parse_mode="Markdown", reply_markup=keyboard)

